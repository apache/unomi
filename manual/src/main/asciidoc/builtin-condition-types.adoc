//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

=== Built-in condition types

Apache Unomi comes with an extensive collection of built-in condition types. Instead of detailing them one by one you will
find here an overview of what a JSON condition descriptor looks like:

[source,json]
----
{
  "metadata": {
    "id": "booleanCondition",
    "name": "booleanCondition",
    "description": "",
    "systemTags": [
      "profileTags",
      "logical",
      "condition",
      "profileCondition",
      "eventCondition",
      "sessionCondition",
      "sourceEventCondition"
    ],
    "readOnly": true
  },
  "conditionEvaluator": "booleanConditionEvaluator",
  "queryBuilder": "booleanConditionESQueryBuilder",
  "parameters": [
    {
      "id": "operator",
      "type": "String",
      "multivalued": false,
      "defaultValue": "and"
    },
    {
      "id": "subConditions",
      "type": "Condition",
      "multivalued": true
    }
  ]
}
----

Note that condition types have three important identifiers:

- conditionEvaluator: For real-time condition evaluation
- queryBuilder: For building search engine queries (either ElasticSearch or OpenSearch)

This is because condition types can be used in three ways:
1. To evaluate a condition in real time
2. To build ElasticSearch queries
3. To build OpenSearch queries

When implementing a new condition type, you need to provide implementations for each use case. Here's an example of OSGi Blueprint registrations for the above condition type descriptor:

[source,xml]
----
<!-- ElasticSearch Query Builder -->
<service interface="org.apache.unomi.persistence.elasticsearch.ConditionESQueryBuilder">
    <service-properties>
        <entry key="queryBuilderId" value="booleanConditionESQueryBuilder"/>
    </service-properties>
    <bean class="org.apache.unomi.persistence.elasticsearch.BooleanConditionESQueryBuilder"/>
</service>

<!-- OpenSearch Query Builder -->
<service interface="org.apache.unomi.persistence.opensearch.ConditionOSQueryBuilder">
    <service-properties>
        <entry key="queryBuilderId" value="booleanConditionOSQueryBuilder"/>
    </service-properties>
    <bean class="org.apache.unomi.persistence.opensearch.BooleanConditionOSQueryBuilder"/>
</service>

<!-- Condition Evaluator (shared between both engines) -->
<service interface="org.apache.unomi.persistence.spi.conditions.ConditionEvaluator">
    <service-properties>
        <entry key="conditionEvaluatorId" value="booleanConditionEvaluator"/>
    </service-properties>
    <bean class="org.apache.unomi.plugins.baseplugin.conditions.BooleanConditionEvaluator"/>
</service>
----

As you can see, three Java classes are used to build a single condition type:
1. A condition evaluator (shared)
2. An ElasticSearch query builder
3. An OpenSearch query builder

You don't need to understand all these details to use condition types, but this might be interesting if you're building your own condition type implementations. For more details on building custom plugins/extensions with search engine specific implementations, please refer to the corresponding sections.

==== Existing condition type descriptors

Here is a non-exhaustive list of condition types built into Apache Unomi. Feel free to browse the source code if you want to discover more. The list below should get you started with the most useful conditions:

- https://github.com/apache/unomi/tree/master/plugins/baseplugin/src/main/resources/META-INF/cxs/conditions

Of course it is also possible to build your own custom condition types by developing custom Unomi plugins/extensions.

You will also note that some condition types can re-use a `parentCondition`. This is a way to inherit from another condition type to make them more specific.
