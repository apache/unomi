//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

== Apache Unomi V2/V3 API Differences Guide

This document explains the key differences between Apache Unomi 2.x and 3.x versions from an API perspective.

== Overview

Apache Unomi 3.x introduces comprehensive multi-tenancy support, enabling complete data isolation between different tenants. This fundamental architectural change requires a new tenant-based authentication model while keeping all API endpoints unchanged.

=== Multi-Tenancy in V3

The key innovation in V3 is the introduction of **tenant isolation** for all data:

- **Profiles, events, segments, rules, and schemas** are now tenant-specific
- **Complete data separation** between tenants - no cross-tenant data access
- **Tenant-specific API keys** for secure access control
- **Backward compatibility** with system administrator access for management operations

This multi-tenancy support necessitates the authentication changes described below, as the system must now identify which tenant context to operate in for every request.

== Key Differences Between V2 and V3

=== Authentication Model

[cols="1,1,1", options="header"]
|===
|Aspect |Unomi V2 |Unomi V3

|Authentication Method
|System Administrator Authentication (karaf/karaf)
|Tenant-based API Keys + System Administrator Authentication

|Public API Endpoints
|No authentication required
|Public API Key required (via X-Unomi-Api-Key header)

|Private API Endpoints
|System Administrator Authentication
|Tenant Authentication (tenantId/privateKey) OR System Administrator Authentication

|Tenant Administration
|System Administrator Authentication (karaf/karaf)
|System Administrator Authentication (karaf/karaf)
|===

=== API Key Types (V3 Only)

V3 introduces two types of API keys per tenant:

- **Public Key**: Used for public endpoints (event collection via `/context.json`)
- **Private Key**: Used with tenantId for tenant-specific administrative operations

=== Authentication Requirements by Endpoint Type

[cols="1,1,1", options="header"]
|===
|Endpoint Category |V2 Authentication |V3 Authentication

|Event Collection (`/context.json`)
|None
|Public API Key only

|Administrative Operations
|System Admin (karaf/karaf)
|Tenant Auth (tenantId/privateKey) OR System Admin (karaf/karaf)

|Tenant Administration (`/cxs/tenants`)
|System Admin (karaf/karaf)
|System Admin (karaf/karaf)
|===

== Authentication Flow (V3)

The AuthenticationFilter in V3 follows this resolution order:

1. **Tenant endpoints** (`/cxs/tenants`): Requires system administrator authentication only
2. **Public endpoints** (e.g., `/context.json`): Requires public API key via `X-Unomi-Api-Key` header
3. **Private endpoints**: Tries tenant authentication first, then falls back to system administrator authentication:
   - **Tenant Authentication**: Basic Auth with `tenantId:privateKey`
   - **System Administrator Authentication**: Basic Auth with `karaf:karaf` (or configured admin credentials)

== Code Examples

=== V2 Authentication

[source,java]
----
// Global system administrator authentication for all endpoints
RestAssured.authentication = RestAssured.preemptive()
    .basic("karaf", "karaf");

// Context requests require no authentication
RestAssured.given()
    .auth().none()
    .contentType(ContentType.JSON)
    .body(contextJson)
    .post("/context.json");
----

=== V3 Authentication

[source,java]
----
// For public endpoints (event collection)
given()
    .header("X-Unomi-Api-Key", publicKey)
    .contentType(ContentType.JSON)
    .body(contextJson)
    .post("/context.json");

// For private endpoints using tenant authentication
given()
    .auth().preemptive().basic(tenantId, privateKey)
    .contentType(ContentType.JSON)
    .body(payload)
    .post("/cxs/profiles");

// For private endpoints using system administrator authentication
given()
    .auth().preemptive().basic("karaf", "karaf")
    .contentType(ContentType.JSON)
    .body(payload)
    .post("/cxs/profiles");

// For tenant administration (system admin only)
given()
    .auth().preemptive().basic("karaf", "karaf")
    .contentType(ContentType.JSON)
    .body(tenantPayload)
    .post("/cxs/tenants");
----

== Implementation Strategy

=== Client Factory Pattern

[source,java]
----
public class UnomiConfiguration {
    public UnomiClient createClient(String baseUrl) {
        String version = System.getProperty("unomi.version", "3");
        
        if ("3".equals(version)) {
            return new UnomiV3Client(baseUrl);
        } else {
            return new UnomiV2Client(baseUrl);
        }
    }
}
----

=== Version-Specific Authentication

[source,java]
----
// V2 Client
public void init() {
    RestAssured.baseURI = baseUrl;
    RestAssured.authentication = RestAssured.preemptive()
        .basic("karaf", "karaf");
}

// V3 Client
public void init() {
    RestAssured.baseURI = baseUrl;
}

public void updateKeys(String publicKey, String privateKey) {
    this.publicKey = publicKey;
    this.privateKey = privateKey;
}
----

== Migration Guidelines

=== From V2 to V3

1. **Understand Multi-Tenancy Impact**
   - All data (profiles, events, segments, rules, schemas) becomes tenant-specific
   - Each tenant operates in complete isolation with their own data space
   - Tenant context must be established for every API operation

2. **Update Authentication Configuration**
   - Remove global system administrator authentication
   - Configure tenant-specific public and private API keys
   - Implement endpoint-specific authentication logic

3. **Endpoint-Specific Changes**
   - Add `X-Unomi-Api-Key` header with public key for event collection
   - Use tenant authentication (tenantId/privateKey) for tenant-specific administrative operations
   - Keep system administrator authentication as fallback for administrative operations
   - Continue using system administrator authentication for tenant administration

4. **No API Contract Changes**
   - All endpoints remain the same
   - Request/response payloads are unchanged
   - Only authentication mechanism differs

=== Benefits of Multi-Tenancy in V3

- **Data Isolation**: Complete separation ensures tenant data never crosses boundaries
- **Scalability**: Support for multiple customers/organizations in a single Unomi instance
- **Security**: Tenant-specific API keys prevent unauthorized cross-tenant access
- **Compliance**: Easier to meet data privacy regulations with clear tenant boundaries
- **Cost Efficiency**: Shared infrastructure with isolated data reduces operational costs

== Conclusion

The fundamental difference between Unomi V2 and V3 is the introduction of **comprehensive multi-tenancy support**:

- **V2**: Single-tenant architecture with system administrator authentication for all operations
- **V3**: Multi-tenant architecture with complete data isolation and tenant-specific authentication
- **API Endpoints**: Identical between versions - no breaking changes to existing integrations
- **Data Model**: All entities (profiles, events, segments, rules, schemas) become tenant-specific in V3
- **Authentication**: New tenant-based authentication model with system administrator authentication as fallback

The authentication changes in V3 are driven by the need to establish tenant context for every operation, ensuring complete data isolation while maintaining backward compatibility for administrative operations. 